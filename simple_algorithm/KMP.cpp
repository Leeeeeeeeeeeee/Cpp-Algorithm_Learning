/*输入两个升序排列的整数数组a1和a2，将a1和a2合并成同一个数组，该新数组仍然按升序排列，要求：使用指针实现。

例如：输入｛1，2，3，5，8｝和｛2，4，6，9｝

输出：｛1，2，2，3，4，5，6，8，9｝*/

// KMP算法
/**
 * KMP（Knuth-Morris-Pratt）算法是一种字符串匹配算法，用于在一个主字符串中查找一个模式字符串的出现位置。该算法的时间复杂度为O(n+m)，其中n是主字符串的长度，m是模式字符串的长度。KMP算法的优势在于，它可以在O(n+m)的时间复杂度内解决字符串匹配问题，而且不需要回溯。

KMP算法的核心思想是利用已经匹配的信息来尽量减少模式字符串和主字符串的比较次数。具体来说，KMP算法维护一个匹配数组next[]，其中next[i]表示在模式字符串中以i结尾的子串的最长公共前后缀的长度。根据这个数组，KMP算法可以在不回溯的情况下进行字符串匹配。

KMP算法的具体实现如下：

首先，计算模式字符串的匹配数组next[]。具体来说，next[i]的值可以递归地定义为next[i-1]和模式字符串前缀与后缀的最长公共长度。例如，对于模式字符串"ababacd"，next[]数组为[0,0,1,2,3,0,0]。

然后，从主字符串的第一个字符开始匹配。具体来说，从主字符串的第一个字符开始，依次比较主字符串和模式字符串的对应字符。如果匹配成功，则继续比较下一个字符；否则，根据next[]数组的值调整模式字符串的位置。

在匹配过程中，如果发现模式字符串的某个字符和主字符串的某个字符不匹配，则根据next[]数组的值调整模式字符串的位置。具体来说，假设模式字符串中第j个字符和主字符串中第i个字符不匹配，那么将模式字符串向右移动j-next[j]个字符，再从主字符串中的第i个字符开始重新匹配。

如果匹配成功，则返回模式字符串在主字符串中的起始位置；否则，继续比较下一个字符，直到主字符串结束。

KMP算法的时间复杂度为O(n+m)，其中n是主字符串的长度，m是模式字符串的长度。虽然KMP算法的实现较为复杂，但它具有良好的时间复杂度和不需要回溯的特点，因此在字符串匹配问题中应用广泛。
*/

#include <iostream>
#include <string.h>
using namespace std;

int main()
{
  int a[5] = {1, 2, 3, 5, 8};
  int b[4] = {2, 4, 6, 8};
  int len = sizeof(a) / sizeof(a[0]) + sizeof(b) / sizeof(b[0]);
  int c[len - 1];
  int i_a = 0, i_b = 0;
  for (int i = 0; i < len - 1; i++)
  {
    if (a[i_a] < b[i_b])
    {
      c[i] = a[i_a];
      i_a++;
    }
    else
    {
      c[i] = b[i_b];
      i_b++;
    }
  }

  for (int i = 0; i < len - 1; i++)
  {
    cout << c[i];
  }
}
